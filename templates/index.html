{% extends "base.html" %}

{% block page_header %}
<div class="d-flex justify-content-between align-items-center mb-3">
  <div>
    <div class="stl-page-title">Bookings</div>
  </div>
  <div>
    <button id="newBookingButton" class="btn btn-primary btn-sm">
      <span class="gradient"></span>
      <span class="label">+ New booking</span>
      <span class="transition"></span>
    </button>
  </div>
</div>
{% endblock %}

{% block page_content %}
<div id="status-bar"></div>

<section class="stl-card stl-card-large mt-3">
  <div class="stl-card-header bookings-header">
    <div class="bookings-header-main">
      <h2 class="stl-card-title mb-0">Bookings</h2>
      
      <div class="booking-date-nav">
        <!-- Previous day -->
        <a href="{{ url_for('index', date=prev_date.isoformat()) }}"
           class="booking-date-nav-btn"
           aria-label="Previous day">
          ‚Üê
        </a>

        <!-- Current date label -->
        <span class="booking-date-label">
          {{ current_date.strftime("%A %d %B %Y") }}
        </span>

        <!-- Next day -->
        <a href="{{ url_for('index', date=next_date.isoformat()) }}"
           class="booking-date-nav-btn"
           aria-label="Next day">
          ‚Üí
        </a>

        <!-- Calendar / date picker -->
        <form method="get"
              action="{{ url_for('index') }}"
              class="booking-date-picker-form">
          <label class="booking-date-picker">
            <span class="booking-date-picker-icon" aria-hidden="true">üìÖ</span>
            <input
              type="date"
              name="date"
              value="{{ current_date.isoformat() }}"
              class="booking-date-picker-input"
              onchange="this.form.submit()">
          </label>
        </form>
      </div>
    </div>

    <div class="bookings-header-meta">
      <span>Total bookings: {{ total_bookings }}</span>
      <span> ‚Ä¢ </span>
      <span>Total seats: {{ total_seats }}</span>
    </div>
  </div>
  <div class="p-3">
    <table id="bookings-table" class="table table-hover mb-0">
      <thead>
        <tr>
          <th>Guest Name</th>
          <th>Party Size</th>
          <th>Start Time</th>
          <th>End Time</th>
          <th>Table ID</th>
          <th></th>
        </tr>
      </thead>
      <tbody id="bookings-body">
        {% include "partials/bookings_table_rows.html" %}
      </tbody>
    </table>
  </div>
</section>

<!-- Popup for table info -->
<div id="table-popup" class="popup" style="display:none;"></div>

  <!-- Server-provided bookings JSON for this page (MUST come before init script) -->
  <script id="server-bookings-json" type="application/json">{{ bookings | tojson }}</script>
  
  <script>
  // Global state
  let currentBookings = [];
  let currentBookingsAll = [];
  let currentTables = [];
  let editingIndex = null; // absolute index used when editing a booking

    // Drawing transform (scale + offset to fit/center content in canvas)
    let drawScale = 1;
    let drawOffsetX = 0;
    let drawOffsetY = 0;

    // Status bar utility
    function showStatus(message, type = 'info') {
      const bar = document.getElementById('status-bar');
      bar.textContent = message;
      bar.className = type; // 'success', 'error', or 'info'
      
      // Auto-hide after 5 seconds
      setTimeout(() => {
        bar.style.display = 'none';
        bar.className = '';
      }, 5000);
    }

    function parseTimeToMinutes(hhmm) {
      if (!hhmm || typeof hhmm !== 'string') return null;
      const parts = hhmm.split(':');
      const h = parseInt(parts[0], 10);
      const m = parts.length > 1 ? parseInt(parts[1], 10) : 0;
      if (Number.isNaN(h) || Number.isNaN(m)) return null;
      return h * 60 + m;
    }

    function isBookingActiveAt(timeMinutes, booking) {
      if (timeMinutes == null) return true; // no filter applied
      const start = parseTimeToMinutes(booking.start_time);
      const end = parseTimeToMinutes(booking.end_time);
      if (start == null || end == null) return true;
      return timeMinutes >= start && timeMinutes < end;
    }

    async function loadTables() {
      try {
        const res = await fetch('/tables');
        if (!res.ok) {
          const data = await res.json().catch(() => ({}));
          showStatus('Error loading tables: ' + (data.error || res.statusText), 'error');
          return;
        }
        const data = await res.json();
        currentTables = Array.isArray(data) ? data : [];
        const container = document.getElementById('tables');
        if (container) {
          container.innerHTML = '';
          currentTables.forEach(t => {
            const div = document.createElement('div');
            div.className = 'table-box';
            div.textContent = `Table ${t.id} (${t.seats} seats)`;
            container.appendChild(div);
          });
        }
        // After listing, draw the floorplan; if bookings already present, color with bookings
        if (currentBookings && currentBookings.length > 0) {
          drawTablesWithBookings(currentTables, currentBookings);
        } else {
          drawFloorplan(currentTables);
        }
      } catch (err) {
        console.error('Load tables error:', err);
        showStatus('Failed to load tables: ' + err.message, 'error');
      }
    }

    function refreshLayout() {
      // Re-fetch tables and redraw; bookings overlay will be applied if available
      loadTables();
    }

    async function reloadTables() {
      try {
        showStatus('Reloading tables...', 'info');
        await loadTables();
        showStatus('Tables reloaded successfully', 'success');
      } catch (err) {
        console.error('Reload tables error:', err);
        showStatus('Failed to reload tables: ' + err.message, 'error');
      }
    }

    async function optimizeLayout() {
      const dateInput = document.getElementById('date-input').value;
      if (!dateInput) {
        showStatus('Pick a date first', 'error');
        return;
      }
      try {
        showStatus('Optimizing layout...', 'info');
        const res = await fetch('/optimize', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ date: dateInput })
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          // Prefer backend error message; include first validation error if present
          let msg = data.error || (Array.isArray(data.errors) && data.errors[0]) || 'Optimization failed';
          showStatus(msg, 'error');
          return;
        }

        // Success response; update tables in-memory
        const newTables = Array.isArray(data.tables) ? data.tables : [];
        currentTables = newTables;

        // Update list UI
        const container = document.getElementById('tables');
        container.innerHTML = '';
        currentTables.forEach(t => {
          const div = document.createElement('div');
          div.className = 'table-box';
          div.textContent = `Table ${t.id} (${t.seats} seats)`;
          container.appendChild(div);
        });

        // Redraw canvas with new layout
        if (currentBookings && currentBookings.length > 0) {
          drawTablesWithBookings(currentTables, currentBookings);
        } else {
          drawFloorplan(currentTables);
        }

        // Only show optimisation success if layout actually changed
        if (data.optimized) {
          // Reload tables from backend to keep UI fully in sync (will overwrite positions if persisted)
          await reloadTables();
          // After reload status messages, show final success per requirement
          showStatus('Layout optimised', 'success');
        } else {
          showStatus(data.message || 'No optimization needed', 'info');
        }
      } catch (err) {
        console.error('Optimize error', err);
        showStatus('Optimization request failed. Check console for details.', 'error');
      }
    }

    // Compute a drawing transform so the tables from tables.json fit inside the canvas
    function computeDrawingTransform(tables) {
      const canvas = document.getElementById('floorplan');
      if (!canvas || !Array.isArray(tables) || tables.length === 0) {
        drawScale = 1; drawOffsetX = 0; drawOffsetY = 0; return;
      }
      // Determine the content bounds in table coordinate space
      let maxX = 0, maxY = 0;
      for (const t of tables) {
        const x = (typeof t.x === 'number' ? t.x : 0) + (typeof t.width === 'number' ? t.width : 60);
        const y = (typeof t.y === 'number' ? t.y : 0) + (typeof t.height === 'number' ? t.height : 60);
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      }
      const margin = 20; // keep a small margin inside the canvas
      const fitScale = Math.min(
        (canvas.width - margin) / (maxX || 1),
        (canvas.height - margin) / (maxY || 1),
        1
      );
      // Optional hint scale to keep everything comfortable inside the canvas
      const SCALE_HINT = 0.8; // tweakable if you want more/less zoom
      drawScale = Math.min(fitScale, SCALE_HINT);
      const contentW = maxX * drawScale;
      const contentH = maxY * drawScale;
      // Center the content
      drawOffsetX = Math.max(0, (canvas.width - contentW) / 2);
      drawOffsetY = Math.max(0, (canvas.height - contentH) / 2);
    }

    // Canvas interaction helpers
    function getCanvasPos(evt) {
      const canvas = document.getElementById('floorplan');
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return {
        x: (evt.clientX - rect.left) * scaleX,
        y: (evt.clientY - rect.top) * scaleY,
        pageX: evt.pageX,
        pageY: evt.pageY,
      };
    }

    function findTableAt(x, y, tables) {
      if (!Array.isArray(tables)) return null;
      const scale = drawScale || 1;
      // Convert from canvas coordinates to table (world) coordinates
      const worldX = (x - drawOffsetX) / scale;
      const worldY = (y - drawOffsetY) / scale;
      // Iterate from last to first so later-drawn tables could take precedence
      for (let i = tables.length - 1; i >= 0; i--) {
        const t = tables[i];
        const tx = typeof t.x === 'number' ? t.x : 0;
        const ty = typeof t.y === 'number' ? t.y : 0;
        const tw = typeof t.width === 'number' ? t.width : 60;
        const th = typeof t.height === 'number' ? t.height : 60;
        if (worldX >= tx && worldX <= tx + tw && worldY >= ty && worldY <= ty + th) {
          return t;
        }
      }
      return null;
    }

    function hidePopup() {
      const p = document.getElementById('table-popup');
      p.style.display = 'none';
    }

    function showPopup(pageX, pageY, table, bookings) {
      const p = document.getElementById('table-popup');
      const items = (bookings || []).map(b => `‚Ä¢ ${b.name} ‚Äî ${b.party_size} ppl, ${b.start_time}-${b.end_time}`).join('<br>');
      const content = `
        <div class="title">Table ${table.id} (${table.seats} seats)</div>
        <div class="close" onclick="hidePopup()">‚úñ</div>
        ${items || '<em>No bookings at selected time</em>'}
      `;
      p.innerHTML = content;
      p.style.left = (pageX + 10) + 'px';
      p.style.top = (pageY + 10) + 'px';
      p.style.display = 'block';
    }

    function showTableDetails(table, bookings) {
      const panel = document.getElementById('table-details');
      let html = `<h3>Table ${table.id}</h3>`;
      html += `<p><strong>Capacity:</strong> ${table.seats} seats</p>`;
      html += `<p><strong>Position:</strong> (${table.x}, ${table.y})</p>`;
      html += `<p><strong>Size:</strong> ${table.width} √ó ${table.height}</p>`;
      
      const timeFilter = document.getElementById('time-filter').value;
      const timeDisplay = timeFilter ? ` at ${timeFilter}` : '';
      html += `<h4 style="margin-top: 12px; margin-bottom: 6px;">Bookings${timeDisplay}</h4>`;
      
      if (!bookings || bookings.length === 0) {
        html += `<p class="no-selection">No bookings for this table</p>`;
      } else {
        bookings.forEach(b => {
          html += `<div class="booking-item">`;
          html += `<strong>${b.name}</strong><br>`;
          html += `Party of ${b.party_size}<br>`;
          html += `${b.start_time} - ${b.end_time}`;
          html += `</div>`;
        });
      }
      
      panel.innerHTML = html;
    }

    function onCanvasClick(evt) {
      const pos = getCanvasPos(evt);
      const table = findTableAt(pos.x, pos.y, currentTables);
      if (!table) { 
        // Reset to default message if clicking outside tables
        const panel = document.getElementById('table-details');
        panel.innerHTML = '<div class="no-selection">Click on a table to view details</div>';
        return; 
      }
      const matches = (currentBookings || []).filter(b => b.table_id === table.id);
      showTableDetails(table, matches);
    }

    // Draw all tables with a neutral gray style
    function drawFloorplan(tables) {
      const canvas = document.getElementById('floorplan');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      // Compute transform to fit within canvas
      computeDrawingTransform(tables);

      // Clear previous drawing
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Optional light background
      ctx.fillStyle = '#F7F4EE';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      tables.forEach(t => {
        const x = typeof t.x === 'number' ? t.x : 0;
        const y = typeof t.y === 'number' ? t.y : 0;
        const w = typeof t.width === 'number' ? t.width : 60;
        const h = typeof t.height === 'number' ? t.height : 60;
        const sx = drawOffsetX + x * drawScale;
        const sy = drawOffsetY + y * drawScale;
        const sw = w * drawScale;
        const sh = h * drawScale;
        // Neutral gray table
        ctx.fillStyle = '#d1d5db';
        ctx.strokeStyle = '#6b7280';
        // Table rectangle
        ctx.fillRect(sx, sy, sw, sh);
        ctx.lineWidth = 1;
        ctx.strokeRect(sx, sy, sw, sh);

        // Table ID text (ensure readable)
  ctx.font = '12px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  // Add a light outline for contrast
  ctx.lineWidth = 3;
  ctx.strokeStyle = 'rgba(255,255,255,0.85)';
  ctx.strokeText(`T${t.id}`, sx + sw / 2, sy + sh / 2);
  ctx.fillStyle = '#0C1C2C';
  ctx.fillText(`T${t.id}`, sx + sw / 2, sy + sh / 2);
      });
    }

    // Draw tables colored by booking data: red if booked at the selected time, green otherwise
    function drawTablesWithBookings(tables, bookings) {
      const canvas = document.getElementById('floorplan');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      // Compute transform to fit within canvas
      computeDrawingTransform(tables);

      // Build a set of booked table_ids
      const bookedSet = new Set();
      if (Array.isArray(bookings)) {
        bookings.forEach(b => {
          if (b && b.table_id !== null && b.table_id !== undefined) {
            bookedSet.add(b.table_id);
          }
        });
      }

      // Clear and background
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#F7F4EE';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw each table with red/green
      tables.forEach(t => {
        const x = typeof t.x === 'number' ? t.x : 0;
        const y = typeof t.y === 'number' ? t.y : 0;
        const w = typeof t.width === 'number' ? t.width : 60;
        const h = typeof t.height === 'number' ? t.height : 60;
        const sx = drawOffsetX + x * drawScale;
        const sy = drawOffsetY + y * drawScale;
        const sw = w * drawScale;
        const sh = h * drawScale;

        if (bookedSet.has(t.id)) {
          // Booked: red
          ctx.fillStyle = '#fecaca';
          ctx.strokeStyle = '#dc2626';
        } else {
          // Free: light blue
          ctx.fillStyle = '#B9DFF5';
          ctx.strokeStyle = '#0C1C2C';
        }
        ctx.fillRect(sx, sy, sw, sh);
        ctx.lineWidth = 1;
        ctx.strokeRect(sx, sy, sw, sh);

        // ID text with outline
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.lineWidth = 3;
        ctx.strokeStyle = 'rgba(255,255,255,0.85)';
        ctx.strokeText(`T${t.id}`, sx + sw / 2, sy + sh / 2);
        ctx.fillStyle = '#0C1C2C';
        ctx.fillText(`T${t.id}`, sx + sw / 2, sy + sh / 2);
      });
    }

    function renderBookingsTable() {
      // Render bookings into the table
      const tbody = document.getElementById('bookings-body');
      tbody.innerHTML = '';
      
      if (currentBookings.length === 0) {
        const row = document.createElement('tr');
        row.innerHTML = '<td colspan="6" style="padding: 12px; text-align: center; color: var(--stl-gray);">No bookings found</td>';
        tbody.appendChild(row);
      } else {
        currentBookings.forEach((b, idx) => {
          const absoluteIndex = currentBookingsAll.indexOf(b); // Map filtered booking back to master list
          const row = document.createElement('tr');
          row.style.borderBottom = '1px solid var(--st-border)';
          row.setAttribute('data-booking-index', absoluteIndex);
          
          // Title-case the name for display
          const displayName = (b.name || 'N/A').split(' ').map(word => 
            word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
          ).join(' ');
          
          // Build actions column with "Show notes" button first (if exists), then Edit button, then cancel icon
          let actionsHTML = '';
          
          // Add "Show notes" button first if notes exist
          if (b.notes && b.notes.trim()) {
            const escapedNotes = (b.notes || '').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
            actionsHTML += `
              <button 
                type="button" 
                class="booking-notes-btn" 
                data-notes="${escapedNotes}">
                Notes
              </button>
            `;
          }
          
          // Add Edit button
          const escapedName = (b.name || '').replace(/"/g, '&quot;');
          const escapedNotesForEdit = (b.notes || '').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
          const tablesJSON = JSON.stringify(b.tables || (b.table_id ? [b.table_id] : []));
          actionsHTML += `
            <button
              type="button"
              class="booking-edit-btn"
              data-booking-index="${absoluteIndex}"
              data-name="${escapedName}"
              data-party-size="${b.party_size || 2}"
              data-date="${b.date || ''}"
              data-start-time="${b.start_time || ''}"
              data-end-time="${b.end_time || ''}"
              data-table-id="${b.table_id || ''}"
              data-tables='${tablesJSON.replace(/'/g, '&#39;')}'
              data-notes="${escapedNotesForEdit}"
              data-phone="${(b.phone || '').replace(/"/g, '&quot;').replace(/'/g, '&#39;')}">
              Edit
            </button>
          `;
          
          // Add cancel icon last (always on the right)
          actionsHTML += `
            <button 
              class="booking-icon-btn" 
              onclick="deleteBooking(${absoluteIndex})"
              title="Cancel booking"
              aria-label="Cancel booking">
              ‚úï
            </button>
          `;
          
          row.innerHTML = `
            <td style="padding: 8px;">${displayName}</td>
            <td style="padding: 8px;">${b.party_size || 'N/A'}</td>
            <td style="padding: 8px;">${b.start_time || 'N/A'}</td>
            <td style="padding: 8px;">${b.end_time || 'N/A'}</td>
            <td style="padding: 8px;">${b.table_id !== null && b.table_id !== undefined ? b.table_id : 'N/A'}</td>
            <td class="booking-actions-cell" style="padding: 8px;">
              ${actionsHTML}
            </td>
          `;
          tbody.appendChild(row);
        });
        
        // Attach event listeners to "Show notes" buttons
        document.querySelectorAll('.booking-notes-btn').forEach(btn => {
          btn.addEventListener('click', function() {
            const notes = this.getAttribute('data-notes') || '';
            if (notes.trim()) {
              alert(notes);
            }
          });
        });
      }

      // Color the floorplan using bookings
      drawTablesWithBookings(currentTables, currentBookings);
    }

    async function loadBookings() {
      const dateInput = document.getElementById('date-input');
      if (!dateInput) {
        // If no date input exists (removed from sidebar), skip AJAX loading
        return;
      }
      
      const dateInputValue = dateInput.value;
      if (!dateInputValue) {
        showStatus('Pick a date first', 'error');
        return;
      }
      
      try {
        const res = await fetch(`/bookings?date=${dateInputValue}`);
        if (!res.ok) {
          const data = await res.json().catch(() => ({}));
          showStatus('Error loading bookings: ' + (data.error || res.statusText), 'error');
          return;
        }
        const data = await res.json();
        // Save all bookings for the selected date (unfiltered)
        currentBookingsAll = Array.isArray(data) ? data : [];

        // Update summary (totals for the whole date)
        updateBookingsSummary();

        currentBookings = currentBookingsAll;

        renderBookingsTable();
      } catch (err) {
        console.error('Load bookings error:', err);
        showStatus('Failed to load bookings: ' + err.message, 'error');
      }
    }

    function updateBookingsSummary() {
      try {
        const el = document.getElementById('bookings-summary');
        if (!el) return;
        const total = Array.isArray(currentBookingsAll) ? currentBookingsAll.length : 0;
        const seats = (currentBookingsAll || []).reduce((sum, b) => sum + (Number(b.party_size) || 0), 0);
        el.textContent = `Total bookings: ${total} ‚Ä¢ Total seats: ${seats}`;
      } catch (e) {
        // no-op
      }
    }

    // REMOVED: Old createBooking() function that referenced deleted inline form fields
    // (#name, #party, #start, #end, #create-booking-btn, #booking-loading)
    // Now using modal form with handler in main.js instead
    /*
    async function createBooking() {
      const dateInput = document.getElementById('date-input').value;
      const name = document.getElementById('name').value;
      const party = document.getElementById('party').value;
      const start = document.getElementById('start').value;
      const end = document.getElementById('end').value;

      if (!dateInput || !name || !party || !start || !end) {
        showStatus('Please fill out all fields', 'error');
        return;
      }

      // Disable button and show loading state
      const btn = document.getElementById('create-booking-btn');
      const loadingMsg = document.getElementById('booking-loading');
      btn.disabled = true;
      btn.style.opacity = '0.6';
      btn.style.cursor = 'not-allowed';
      loadingMsg.style.display = 'inline';

      try {
        const res = await fetch('/bookings', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            date: dateInput,
            name: name,
            party_size: Number(party),
            start_time: start,
            end_time: end
          })
        });

        const data = await res.json();
        if (!res.ok) {
          showStatus('Error: ' + (data.error || 'Unknown error'), 'error');
        } else {
          showStatus(`Booking created for ${name}, party of ${party} at table ${data.table.id}!`, 'success');
          // Clear form
          document.getElementById('name').value = '';
          document.getElementById('party').value = '';
          document.getElementById('start').value = '';
          document.getElementById('end').value = '';
          // Reload bookings to show the new one
          loadBookings();
        }
      } finally {
        // Re-enable button and hide loading state
        btn.disabled = false;
        btn.style.opacity = '1';
        btn.style.cursor = 'pointer';
        loadingMsg.style.display = 'none';
      }
    }
    */

    // REMOVED: Old updateBooking() function that referenced deleted inline form fields
    /*
    // Submit update via PUT /bookings
    async function updateBooking() {
      if (editingIndex == null || editingIndex < 0 || editingIndex >= currentBookingsAll.length) {
        showStatus('No booking selected for update', 'error');
        return;
      }
      const dateInput = document.getElementById('date-input').value;
      const name = document.getElementById('name').value;
      const party = document.getElementById('party').value;
      const start = document.getElementById('start').value;
      const end = document.getElementById('end').value;
      if (!dateInput || !name || !party || !start || !end) {
        showStatus('Please fill out all fields', 'error');
        return;
      }
      const btn = document.getElementById('create-booking-btn');
      const loadingMsg = document.getElementById('booking-loading');
      btn.disabled = true;
      btn.style.opacity = '0.6';
      btn.style.cursor = 'not-allowed';
      loadingMsg.style.display = 'inline';
      try {
        const res = await fetch('/bookings', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            date: dateInput,
            index: editingIndex,
            name: name,
            party_size: Number(party),
            start_time: start,
            end_time: end
          })
        });
        const data = await res.json();
        if (!res.ok) {
          showStatus('Update failed: ' + (data.error || 'Unknown error'), 'error');
          return;
        }
        showStatus('Booking updated successfully', 'success');
        // Reset form & state
        document.getElementById('name').value = '';
        document.getElementById('party').value = '';
        document.getElementById('start').value = '';
        document.getElementById('end').value = '';
        editingIndex = null;
        btn.textContent = 'Create';
        btn.onclick = createBooking;
        await loadBookings();
      } catch (err) {
        console.error('Update booking error:', err);
        showStatus('Update failed: ' + err.message, 'error');
      } finally {
        btn.disabled = false;
        btn.style.opacity = '1';
        btn.style.cursor = 'pointer';
        loadingMsg.style.display = 'none';
      }
    }
    */

    // REMOVED: Old editBooking() function that referenced deleted inline form fields
    /*
    // Begin editing: populate form and switch button to Update mode
    function editBooking(index) {
      if (index == null || index < 0 || index >= currentBookingsAll.length) {
        showStatus('Invalid booking index', 'error');
        return;
      }
      const b = currentBookingsAll[index];
      editingIndex = index;
      document.getElementById('name').value = b.name || '';
      document.getElementById('party').value = b.party_size || '';
      document.getElementById('start').value = b.start_time || '';
      document.getElementById('end').value = b.end_time || '';
      const btn = document.getElementById('create-booking-btn');
      btn.textContent = 'Update booking';
      btn.onclick = updateBooking;
      showStatus('Loaded booking into form. Edit and press "Update booking".', 'info');
    }
    */

    // Delete booking via backend, then refresh UI
    async function deleteBooking(index) {
      if (index == null || index < 0 || index >= currentBookingsAll.length) {
        showStatus('Invalid booking index', 'error');
        return;
      }
      const b = currentBookingsAll[index];
      const dateInput = document.getElementById('date-input').value;
      if (!dateInput) {
        showStatus('Pick a date first', 'error');
        return;
      }
      const conf = confirm(`Delete booking "${b.name || 'N/A'}" (${b.start_time || '?'} - ${b.end_time || '?'})?`);
      if (!conf) return;
      try {
        const res = await fetch(`/bookings?date=${encodeURIComponent(dateInput)}&index=${index}` , { method: 'DELETE' });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          showStatus('Delete failed: ' + (data.error || res.statusText), 'error');
          return;
        }
        showStatus('Booking deleted', 'success');
        await loadBookings();
      } catch (err) {
        console.error('Delete booking error:', err);
        showStatus('Delete failed: ' + err.message, 'error');
      }
    }

    // Initialize on page load
    (function init() {
      // Load server-side bookings data (avoid inline JS object to prevent parser errors)
      let serverBookings = [];
      const serverBookingsEl = document.getElementById('server-bookings-json');
      if (serverBookingsEl) {
        try {
          serverBookings = JSON.parse(serverBookingsEl.textContent);
        } catch (e) {
          serverBookings = [];
        }
      }
      currentBookingsAll = serverBookings || [];
      currentBookings = currentBookingsAll;
      
      // Render bookings into the table
      renderBookingsTable();
      
      // Load tables immediately
      loadTables();
    })();
  </script>
  
  <script>
    // Attach canvas click handler after DOM loads
    (function attachCanvasHandler(){
      const canvas = document.getElementById('floorplan');
      if (!canvas) return;
      canvas.addEventListener('click', onCanvasClick);
    })();
  </script>

  <!-- Include edit booking modal -->
  {% include "partials/booking_edit_modal.html" %}
  
  <!-- Include edit booking JS -->
  <script src="{{ url_for('static', filename='js/booking_edit.js') }}"></script>
{% endblock %}
